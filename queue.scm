;;; queue implementation as a procedure with local state
(define (make-queue)
	(let ((front-ptr '())
	      (rear-ptr  '()))
	(define (empty?)
		(null? front-ptr))
	(define (front)
		(if (empty?)
			(error "FRONT called on empty queue" front-ptr)
			(car front-ptr)))
	(define (insert item)
		(let ((new-pair (cons item '())))
			(cond ((empty?)
			        (set! front-ptr new-pair)
			        (set! rear-ptr  new-pair))
		          (else (set-cdr! rear-ptr new-pair)
			            (set! rear-ptr new-pair)))))
	(define (delete)
		(if (empty?)
			(error "DELETE called on empty queue" front-ptr)
			(set! front-ptr (cdr front-ptr))))
	(define (dispatch m)
		(cond ((eq? m 'front)  front)
		      ((eq? m 'empty?) empty?)
		      ((eq? m 'insert) insert)
		      ((eq? m 'delete) delete)
		      (else (error "unknown queue operation" m))))
	dispatch))

(define (front-queue  queue)   ((queue 'front)))
(define (empty-queue? queue)  ((queue 'empty?)))
(define (insert-queue queue a) ((queue 'insert) a))
(define (delete-queue queue)   ((queue 'delete)))

;;; a deque implementation as a pair of a front/rear/pre-rear pointer list
(define (make-deque)
	(cons '() '()))
(define (front-ptr deque)
	(car deque))
(define (rear-ptr deque)
	(cdr deque))
(define (set-front-ptr! deque val)
	(set-car! deque val))
(define (set-rear-ptr! deque val)
	(set-cdr! deque val))

(define (empty-deque? deque)
	(null? (front-ptr deque)))

(define (make-deque-element val prev next)
	(cons val (cons prev next)))
(define (value-deque-element el)
	(car el))
(define (prev-deque-element el)
	(cadr el))
(define (next-deque-element el)
	(cddr el))
(define (set-prev-deque-element! el val)
	(set-car! (cdr el) val))
(define (set-next-deque-element! el val)
	(set-cdr! (cdr el) val))

(define (front-insert-deque! deque val)
	(let ((new-element (make-deque-element val '() (front-ptr deque))))
		(cond ((empty-deque? deque)
		       (set-front-ptr! deque new-element)
		       (set-rear-ptr!  deque new-element)
		       deque)
		      (else (set-front-ptr! deque new-element)
		            deque))))

(define (rear-insert-deque! deque val)
	(let ((new-element (make-deque-element val (rear-ptr deque) '())))
		(cond ((empty-deque? deque)
		       (set-front-ptr! deque new-element)
		       (set-rear-ptr!  deque new-element)
		       deque)
		      (else (set-next-deque-element! (rear-ptr deque) new-element)
		            (set-rear-ptr! deque new-element)
		            deque))))

(define (front-deque deque)
	(if (empty-deque? deque)
		(error "FRONT on empty deque" deque)
		(value-deque-element (front-ptr deque))))
(define (rear-deque deque)
	(if (empty-deque? deque)
		(error "REAR on empty deque" deque)
		(value-deque-element (rear-ptr deque))))

(define (front-delete-deque! deque)
	(if (empty-deque? deque)
		(error "FRONT-DELETE on empty deque" deque)
		(begin (set-front-ptr! deque (next-deque-element (front-ptr deque)))
		       (set-prev-deque-element! (front-ptr deque) '()))))
(define (rear-delete-deque! deque)
	(if (empty-deque? deque)
		(error "REAR-DELETE on empty deque" deque)
		(begin (set-rear-ptr! deque (prev-deque-element (rear-ptr deque)))
		       (set-next-deque-element! (rear-ptr deque) '()))))

(define (display-deque deque)
	(define (iter element)
		(cond ((null? element)
		        (display " )") (newline))
		      (else (display " ")
		            (display (value-deque-element element))
		            (iter (next-deque-element element)))))
	(display "(")
	(iter (front-ptr deque)))
